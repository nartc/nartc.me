---
title: Convert a vanilla THREE.js Angular application to Angular Three
description: Convert Angular WebXR Art Sample, an Angular application with vanilla THREE.js, to Angular Three for a better DX to writing 3D with Angular
slug: convert-threejs-to-angular-three
publishedAt: 2024-05-19
tags: ["Angular", "Three.js"]
---

import { Tabs, TabItem } from "@astrojs/starlight/components";
import BlogImage from "../../components/BlogImage.astro";
import angularWebXR from "../../assets/convert-angular-three/angularWebXR.gif";
import floorWalls from "../../assets/convert-angular-three/floorWalls.png";
import framesCommentedOut from "../../assets/convert-angular-three/framesCommentedOut.png";
import lightsCommentedOut from "../../assets/convert-angular-three/lightsCommentedOut.png";
import noLights from "../../assets/convert-angular-three/noLights.png";
import fullFrame from "../../assets/convert-angular-three/fullFrame.png";
import imageOnly from "../../assets/convert-angular-three/imageOnly.png";
import frameOnly from "../../assets/convert-angular-three/frameOnly.png";
import frameButtonsOnly from "../../assets/convert-angular-three/frameButtonsOnly.png";

A couple of days ago, I found a cool [Angular](https://angular.dev) WebXR Art Sample application on [Google Gemini GitHub](https://github.com/google-gemini/angular-webxr-art-sample). The application was built using vanilla [THREE.js](https://threejs.org). I thought it would be a good idea to convert it to Angular Three (i.e: `angular-three`), a library that provides a custom Angular Renderer to render THREE.js entities. This way, I can leverage Angular's features and improve the developer experience when writing 3D applications with Angular.

In this blog post, I will walk you through the steps I took to convert the Angular WebXR Art Sample application to Angular Three. That said, I only focus on the THREE.js conversion process. I won't cover the WebXR nor the Gemini part of the application.

Additionally, I would like to refer you to the [Angular Three with AnalogJS and Astro](./angular-three-analogjs-astro) for an introduction to Angular Three

## The example entry point

Before diving into the conversion process, let's understand the Angular WebXR Art Sample application entry point:  `MuseumComponent`

```angular-html
@defer (prefetch on idle) {
    <art-gallery [artworks]="artworks()" />
} @placeholder ( minimum 5s) {
    <art-loading></art-loading>
} @error {
    <p>Failed to load the gallery</p>
}
```

We can see that there are two branches in the application: `art-gallery` and `art-loading`. The `art-gallery` branch is where the 3D models are rendered, and the `art-loading` branch is a placeholder for the spinning Angular logo.

<BlogImage
	src={angularWebXR}
	format="gif"
	alt="Animated gif of the Angular WebXR application"
/>

Both `art-gallery` and `art-loading` wrap a `canvas` element where the scene graph is rendered to. Both `GalleryComponent` and `LoadingComponent` extend `SceneComponent` which sets up the required building blocks for a THREE.js application:

- A `Scene`
- A `Camera`, more specifically a `PerspectiveCamera`
- A `Renderer`, more specifically a `WebGLRenderer`

```angular-ts
export class SceneComponent {
	/* more code */

	ngAfterViewInit() {
		const canvasEl = this.canvas().nativeElement;

		/* more code */

		// Scene background
		this.scene.background = new Color("black");
		this.scene.backgroundBlurriness = 0.3;

		// Camera
		this.camera = new PerspectiveCamera(45, w / h, 0.1, 500);
		this.camera.position.set(0, 1.6, 0);
		this.scene.add(this.camera);

		// Renderer
		this.renderer = new WebGLRenderer({
			canvas: canvasEl,
			antialias: true,
			powerPreference: "high-performance",
			alpha: true,
		});
		/* more code */
	}

	/* more code */
}
```

In addition, the `SceneComponent` also sets up some lights and an `OrbitControls` for the camera. The `OrbitControls` allows the user to rotate the camera around the scene.

<Tabs>
    <TabItem label="SceneComponent">
```ts
export class SceneComponent {
	/* more code */

    ngAfterViewInit() {
    	/* setup code */

    	// add lights
    	this.addLights();

    	// add controls
    	this.addControls();
    }

    /* more code */

}
```
    </TabItem>
    <TabItem label="addLights()">
```ts
// Camera Lights
const cameraLight: any = this.lightsService.createSpotLight();
cameraLight.position.set( 0, -2, 0.64 );
this.camera.add( cameraLight );

// Ambient Light
const ambient = new HemisphereLight( 0xffffff, 0xbbbbff, 0.5 );
this.scene.add( ambient );
```
    </TabItem>
    <TabItem label="addControls()">
```ts
this.controls = new OrbitControls( this.camera, this.renderer.domElement );
this.controls.listenToKeyEvents( window ); // optional

// Set the controls target to the camera/user position
this.controls.target.set( 0, 1.6, -5 );
this.controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
this.controls.dampingFactor = 0.05;
this.controls.enableZoom = true;

this.controls.screenSpacePanning = false;

this.controls.minDistance = 5;
this.controls.maxDistance = 60;
this.controls.maxPolarAngle = Math.PI / 2 - 0.05; // prevent camera below ground
this.controls.minPolarAngle = Math.PI / 4;        // prevent top down view
this.controls.update();
```
    </TabItem>
</Tabs>

I will not try to explain the code line-by-line here but the gist is that it is **imperative** code that sets up the base environment for the scene graph. For me personally, this code is **hard** to follow and maintain.

Here is the same branched template in the Angular Three rewrite:

```angular-ts
import { ChangeDetectionStrategy, Component } from '@angular/core'
import { GalleryScene } from './gallery-scene.component'
import { LoadingScene } from './loading-scene.component'
import { MuseumCanvas } from './museum-canvas.component'

@Component({
	standalone: true,
	template: `
		@defer (prefetch on idle) {
			<app-museum-canvas [scene]="galleryScene" />
		} @placeholder (minimum 5s) {
			<app-museum-canvas [scene]="loadingScene" />
		}
	`,
    /* truncated */
	imports: [MuseumCanvas],
})
export default class GalleryPage {
	galleryScene = GalleryScene
	loadingScene = LoadingScene
}
```

In this version, `MuseumCanvas` is the component that is responsible for setting up the required building blocks of a 3D scene graph.

```angular-ts '[sceneGraph]="scene()"' "scene = input.required<Type<any>>()"
import { ChangeDetectionStrategy, Component, input, type Type } from '@angular/core'
import { NgtCanvas } from 'angular-three'
import { NgtsLoader } from 'angular-three-soba/loaders'
import * as THREE from 'three'

@Component({
	selector: 'app-museum-canvas',
	standalone: true,
	template: `
		<ngt-canvas
			[sceneGraph]="scene()"
			[scene]="sceneOptions"
			[camera]="$any(cameraOptions)"
			[gl]="glOptions"
			[shadows]="true"
		/>
		<ngts-loader />
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	imports: [NgtCanvas, NgtsLoader],
})
export class MuseumCanvas {
	scene = input.required<Type<any>>()

	protected sceneOptions = {
		background: new THREE.Color('black'),
		backgroundBlurriness: 0.3,
	}

	protected cameraOptions = {
		position: [0, 1.6, 0],
		fov: 45,
		near: 0.1,
		far: 500,
	}

	protected glOptions = {
		toneMappingExposure: 1.5,
		// NOTE: Uncomment the following line to enable WebXR
		// xr: {
		//     enabled: true
		// }
	}
}
```

The highlighted code shows the `MuseumCanvas` accepts a `scene` Input that is passed into the `NgtCanvas` component which will render the scene with the Custom Renderer.

Alright, so that takes care of the `Renderer`, `Scene`, and `Camera`. What about the `OrbitControls` and the lights?
Since we are using Angular Three, we can leverage the declarative approach with the Angular Template to build our _reusable_ `Lights` and `Controls` components

<Tabs>
    <TabItem label="Lights">
```angular-ts
import { ChangeDetectionStrategy, Component, CUSTOM_ELEMENTS_SCHEMA, effect } from '@angular/core'
import { extend, injectNgtStore } from 'angular-three'
import { HemisphereLight, SpotLight } from 'three'

extend({ HemisphereLight })

@Component({
	selector: 'app-lights',
	standalone: true,
	template: `
		<ngt-hemisphere-light skyColor="#ffffff" groundColor="#bbbbff" [intensity]="0.5" />
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	schemas: [CUSTOM_ELEMENTS_SCHEMA],
})
export class Lights {
	protected Math = Math

	private store = injectNgtStore()
	private camera = this.store.select('camera')
	private scene = this.store.select('scene')

	constructor() {
		effect(() => {
			const [camera, scene] = [this.camera(), this.scene()]
			if (!camera || !scene) return

			const spotLight = new SpotLight(0xffffff, 30, 30, Math.PI / 4, 0.5)
			spotLight.position.set(0, -2, 0.64)
			camera.add(spotLight)
			scene.add(camera)
		})
	}
}
```
    </TabItem>
    <TabItem label="Controls">
```angular-ts
import { ChangeDetectionStrategy, Component, CUSTOM_ELEMENTS_SCHEMA, input } from '@angular/core'
import { injectNgtRef } from 'angular-three'
import { NgtsOrbitControls } from 'angular-three-soba/controls'
import { OrbitControls } from 'three-stdlib'

@Component({
	selector: 'app-controls',
	standalone: true,
	template: `
		<ngts-orbit-controls
			[controlsRef]="controlsRef()"
			[target]="[0, 1.6, -5]"
			[dampingFactor]="0.05"
			[enableZoom]="true"
			[screenSpacePanning]="false"
			[minDistance]="5"
			[maxDistance]="60"
			[maxPolarAngle]="Math.PI / 2 - 0.05"
			[minPolarAngle]="Math.PI / 4"
		/>
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	imports: [NgtsOrbitControls],
	schemas: [CUSTOM_ELEMENTS_SCHEMA],
})
export class Controls {
	protected Math = Math
	controlsRef = input(injectNgtRef<OrbitControls>())
}
```
    </TabItem>
    <TabItem label="addLights()">
```ts
// Camera Lights
const cameraLight: any = this.lightsService.createSpotLight();
cameraLight.position.set( 0, -2, 0.64 );
this.camera.add( cameraLight );

// Ambient Light
const ambient = new HemisphereLight( 0xffffff, 0xbbbbff, 0.5 );
this.scene.add( ambient );
```
    </TabItem>
    <TabItem label="addControls()">
```ts
this.controls = new OrbitControls( this.camera, this.renderer.domElement );
this.controls.listenToKeyEvents( window ); // optional

// Set the controls target to the camera/user position
this.controls.target.set( 0, 1.6, -5 );
this.controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
this.controls.dampingFactor = 0.05;
this.controls.enableZoom = true;

this.controls.screenSpacePanning = false;

this.controls.minDistance = 5;
this.controls.maxDistance = 60;
this.controls.maxPolarAngle = Math.PI / 2 - 0.05; // prevent camera below ground
this.controls.minPolarAngle = Math.PI / 4;        // prevent top down view
this.controls.update();
```
    </TabItem>
</Tabs>

If we count the line of code in both approaches, the _imperative_ approach seems to have less code but the _declarative_ approach is more _composable_ where we can drop `<app-lights />` and/or `<app-controls />` in any Scene graph component to have the default lighting and an `OrbitControls`.

## The loading Angular Logo

The loading Angular logo is a placeholder for the `art-loading` branch. In the Angular WebXR Art Sample application, the loading Angular logo is a spinning Angular logo. In the Angular Three rewrite, we use the `LoadingScene` component to render the spinning Angular logo.

<Tabs>
    <TabItem label="LoadingComponent (Angular WebXR)">
```angular-ts 'extends SceneComponent' 'this.onLoad.bind( this )' 'this.createLight()'
// inheritance from SceneComponent
export class LoadingComponent extends SceneComponent {
  /* more code */

  override ngAfterViewInit (): void {
    // sets up the building blocks
    super.ngAfterViewInit();

    // Load the logo
    const model = this.loadersService.loadGLTF( {
      path: '/assets/models/aLogo.glb',
      // callback when the model is loaded
      onLoadCB: this.onLoad.bind( this ),
    } );

    // create additional light for the loading scene
    this.createLight();

  };

  createLight () {
    /* view tab */
  }

  // Place and animate the logo when loaded
  onLoad ( model: Object3D ) {
    /* view tab */
  }

  animate () {
    /* view tab */
  }
}
```
    </TabItem>
    <TabItem label="createLight()">
```ts
// create a Mesh imperatively with THREE.js
this.particleLight = new Mesh(
  new SphereGeometry( .05, 8, 8 ),
  new MeshBasicMaterial( { color: 0xffffff } )
);
// add the Mesh to the scene
this.scene.add( this.particleLight );
// create a PointLight imperatively with THREE.js
const pointLight = new PointLight( 0xffffff, 30 );
// add the PointLight to the Mesh
this.particleLight.add( pointLight );
// set the rotation of the PointLight
pointLight.rotation.x = -Math.PI / 2;
// set the position of the PointLight
this.particleLight.position.z = -90;
this.scene.add( this.particleLight );

// add the animate function to participate in the render loop
this.addToRender( this.animate.bind( this ) );
```
    </TabItem>
    <TabItem label="onLoad()">
```ts
// set the position of the model
model.position.z = -100;
model.position.y = 13;
model.name = 'aLogo';
// add the model to the scene
this.addToScene( model );
// add the animate function to participate in the render loop
this.addToRender( () => {
  model.rotation.y += 0.01;
} );
this.controls.enabled = false;
```
    </TabItem>
    <TabItem label="animate()">
```ts
const timer = Date.now() * 0.00025;
this.particleLight.position.x = Math.sin( timer * 7 ) * 3;
this.particleLight.position.y = Math.cos( timer * 5 ) * 4;
this.particleLight.position.z = Math.cos( timer * 3 ) * 3;
```
    </TabItem>
</Tabs>

Once again, `LoadingComponent` inherits the setup from `SceneComponent` and adds on top of it. It is _not_ apparent how the `LoadingComponent` contributes to the Scene graph.

Here's the Angular Three rewrite:

```angular-ts
import { ChangeDetectionStrategy, Component, computed, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core'
import { extend, injectNgtRef, NgtArgs } from 'angular-three'
import { injectNgtsGLTFLoader } from 'angular-three-soba/loaders'
import { Mesh, PointLight, SphereGeometry, type Object3D } from 'three'
import type { OrbitControls } from 'three-stdlib'
import { Controls } from './controls.component'
import { Lights } from './lights.component'

extend({ Mesh, SphereGeometry, PointLight })

@Component({
	standalone: true,
	template: `
		<!-- addLights -->
		<app-lights />

		<!-- addControls -->
		<app-controls [controlsRef]="controlsRef" />

		<!-- angular logo model -->
		<ngt-primitive *args="[model()]" [position]="[0, 13, -100]" (beforeRender)="onBeforeRender($any($event).object)" />

		<!-- particle light -->
		<ngt-mesh [position]="[0, 0, -90]" (beforeRender)="onParticleLightBeforeRender($any($event).object)">
			<ngt-sphere-geometry *args="[0.05, 8, 8]" />
			<ngt-point-light [intensity]="30" [rotation]="[-Math.PI / 2, 0, 0]" />
		</ngt-mesh>
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	schemas: [CUSTOM_ELEMENTS_SCHEMA],
	imports: [NgtArgs, Lights, Controls],
})
export class LoadingScene {
	protected Math = Math

	protected controlsRef = injectNgtRef<OrbitControls>()

	private gltf = injectNgtsGLTFLoader(() => 'models/aLogo.glb')
	protected model = computed(() => {
		const gltf = this.gltf()
		if (!gltf) return null
		this.controlsRef.nativeElement.enabled = false
		return gltf.scene
	})

	onBeforeRender(object: Object3D) {
		object.rotation.y += 0.01
	}

	onParticleLightBeforeRender(object: Mesh) {
		const timer = Date.now() * 0.00025
		object.position.x = Math.sin(timer * 7) * 3
		object.position.y = Math.cos(timer * 5) * 4
		object.position.z = Math.cos(timer * 3) * 3
	}
}
```

This version is actually so easy to follow that I will explain piece by piece:
- The `LoadingScene` adds the `Lights` and `Controls` components to the scene by dropping `<app-lights />` and `<app-controls />` to the template.
- For the model, we use `injectNgtsGLTFLoader()` in combination with `<ngt-primitive>` special element from Angular Three to display the model. We can apply any properties to the underlying `Object3D` from the external model by using Property Binding on the template.
    - We can use `(beforeRender)` custom event to allow the Object to participate in the render loop.
- For the particle light, we, once again, use the template by leveraging the `<ngt-mesh>` element to create the `Mesh`.
    - As the content child for the `Mesh`, we use `ngt-point-light` to create the `PointLight`
    - The particle light also participates in the render loop so we use `(beforeRender)` custom event to animate the light.


## The Gallery

The `GalleryComponent` is similar to `LoadingComponent` in a sense that it also extends `SceneComponent`.

```angular-ts 'extends SceneComponent' 'this.createFrames()' 'this.createEnv()'
export class GalleryComponent extends SceneComponent {
  /* more code */

  override ngAfterViewInit (): void {

    super.ngAfterViewInit();

    // Focus frame
    this.createFrames();

    // Environment
    this.createEnv();

  };

  createFrames () {
    /* will discuss later */
  }

  createEnv () {
    /* will discuss later */
  }

  /* more code */
};
```

The difference is `GalleryComponent` creates the **Frames** for the artworks and creates its own environment on top of the base environment (i.e: lights)

<Tabs>
    <TabItem label="createEnv()">
We'll be looking at the `createEnv()` method in the `GalleryComponent` that sets up the environment for the gallery. More specifically,
we'll look at `addCornerLights()` and the two callbacks `onModelLoaded()` and `onLoadWallsLoaded()`.

```angular-ts 'this.addCornerLights();' 'this.onModelLoaded( model );' 'this.onLoadWallsLoaded( model );'
export class GalleryComponent extends SceneComponent {
  /* more code */
  createEnv () {

    // Lights
    this.addCornerLights();

    // Add Models
    // Model for Floor
    const model = this.loadersService.loadGLTF( {
      path: "assets/models/floorModel.glb",
      onLoadCB: ( model: Object3D<Object3DEventMap> ) => {
        this.onModelLoaded( model );
      },
    } );

    // Model for Walls
    const modelWalls = this.loadersService.loadGLTF( {
      path: "assets/models/galleryInnerWalls.glb",
      onLoadCB: ( model: Object3D<Object3DEventMap> ) => {
        this.onLoadWallsLoaded( model );
      },
    } );

  }

  /* more code */
}
```
    </TabItem>
    <TabItem label="addCornerLights()">
`GalleryComponent` adds 3 `PointLight` to the scene to create a corner light effect.

```angular-ts 'PointLight' 'pointLight.clone()'
// Corner lights in each inner walls
const pointLight = new PointLight( 0xffffff, Math.PI, 13, 1 );
pointLight.position.y = 3.2;
pointLight.position.z = -10;

const pointLight1 = pointLight.clone();
pointLight1.position.set( 10, 3.2, 7.6 );

const pointLight2 = pointLight.clone();
pointLight2.position.set( -10, 3.2, 7.6 );
this.scene.add( pointLight, pointLight1, pointLight2 );
```
    </TabItem>
    <TabItem label="onModelLoaded() for Floor">
Once we load the model, we'll create a `MeshPhysicalMaterial` for every `Object3D` in the model itself. However, if the `Object3D` is the floor, we'll create a `MeshStandardMaterial` for it with additional textures.

```angular-ts 'createMeshPhysicalMaterial()' 'createFloorMaterial()'
let meshesCount = 0;
let material: Material = this.materialsService.createMeshPhysicalMaterial();

model.position.z = -0;
model.scale.set( 3, 3, 3 );
model.traverse( ( obj: any ) => {

  if ( obj.isMesh ) {
    meshesCount += 1;
    if ( obj.name == 'Floor' ) {
      material = this.materialsService.createFloorMaterial();
    }

    obj.material = material;

    obj.castShadow = true;
    obj.receiveShadow = true;
    obj.castShadow = true;
    obj.receiveShadow = true;

    if ( obj.material.map ) { obj.material.map.anisotropy = 16; }
  }

} );

this.addToScene( model );
```
    </TabItem>
    <TabItem label="createFloorMaterial() for Floor">
We load 3 different files for 3 different textures to apply to the Floor's material.

```angular-ts 'hardwood_diffuse' 'hardwood_bump' 'hardwood_roughness' 'floorMat.map = map' 'floorMat.bumpMap = map' 'floorMat.roughnessMap = map'
const floorMat = new MeshStandardMaterial( {
  roughness: 0.8,
  color: 0xffffff,
  metalness: 0.2,
  bumpScale: 0.0005
} );

// Diffuse
this.loadersService.textureLoader.load( 'assets/textures/hardwood_diffuse.jpg', ( map ) => {
  map.wrapS = RepeatWrapping;
  map.wrapT = RepeatWrapping;
  map.anisotropy = 16;
  map.repeat.set( 10, 24 );
  map.colorSpace = SRGBColorSpace;
  floorMat.map = map;
  floorMat.needsUpdate = true;
},
  undefined,
  // onError callback
  function ( err ) {
    console.error( 'Bump texture failed to load.' );

  }
);

this.loadersService.textureLoader.load( 'assets/textures/hardwood_bump.jpg', function ( map ) {

  map.wrapS = RepeatWrapping;
  map.wrapT = RepeatWrapping;
  map.anisotropy = 4;
  map.repeat.set( 10, 24 );
  floorMat.bumpMap = map;
  floorMat.needsUpdate = true;

},
  undefined,
  // onError callback
  function ( err ) {
    console.error( 'Bump texture failed to load.' );

  } );

this.loadersService.textureLoader.load( 'assets/textures/hardwood_roughness.jpg', function ( map ) {

  map.wrapS = RepeatWrapping;
  map.wrapT = RepeatWrapping;
  map.anisotropy = 4;
  map.repeat.set( 10, 24 );
  floorMat.roughnessMap = map;
  floorMat.needsUpdate = true;

},
  undefined,
  // onError callback
  function ( err ) {
    console.error( 'Bump texture failed to load.' );

  }
);

return floorMat;
```
    </TabItem>
    <TabItem label="onLoadWallsLoaded() for Walls">
For the walls, we just set the position and scale of the model.

```angular-ts
model.position.z = -0;
model.scale.set( 3, 3, 3 );

this.addToScene( model );
```
    </TabItem>
</Tabs>

As you can see here, the _imperativeness_ is an ongoing theme for vanilla THREE.js application development. The `GalleryComponent` is no exception. The `createEnv()` method is a mix of setting up the environment, loading models, and setting up materials for the models.

Here's the Angular Three rewrite:

```angular-ts {'1': 13} {'2': 18-20}
import { ChangeDetectionStrategy, Component } from '@angular/core'
import { ARTWORKS } from '../artworks'
import { Controls } from './controls.component'
import { Floor } from './floor.component'
import { Frames } from './frames.component'
import { GalleryLights } from './gallery-lights.component'
import { Walls } from './walls.component'

@Component({
	standalone: true,
	template: `
		<!-- addControls -->
		<app-controls />

		<app-frames [artworks]="artworks" />

		<!-- createEnv -->
		<app-gallery-lights />
		<app-floor />
		<app-walls />
		<!-- end createEnv -->
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	host: { class: 'experience' },
	imports: [Controls, Frames, Floor, Walls, GalleryLights],
})
export class GalleryScene {
	protected artworks = ARTWORKS
}
```

First off, we compose `<app-controls />` to set up the `OrbitControls`. We'll skip `<app-frames />` for now and focus on the `createEnv` part. We drop `<app-gallery-lights />`, `<app-floor />`, and `<app-walls />` to the template to set up the additional lights, the floor, and the walls. It is already a lot clearer to see what the `GalleryScene` is doing.

<Tabs>
    <TabItem label="GalleryLights">
Composition is the key here once again. We compose `<app-lights />` (1) to set up the default lights then add 3 `PointLight` to the scene to create a corner light effect. Since we operate on the template, we can leverage control flow like `@for` to create the corner lights based on the predefined corner `positions` (2).

```angular-ts {'1': 13} {'2': 16-18}
import { ChangeDetectionStrategy, Component, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core'
import { extend } from 'angular-three'
import { PointLight } from 'three'
import { Lights } from './lights.component'

extend({ PointLight })

@Component({
	selector: 'app-gallery-lights',
	standalone: true,
	template: `
		<!-- addLights -->
		<app-lights />

		<!-- addCornerLights -->
		@for (position of lightPositions; track $index) {
			<ngt-point-light [intensity]="Math.PI" [distance]="13" [decay]="1" [position]="position" />
		}
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	schemas: [CUSTOM_ELEMENTS_SCHEMA],
	imports: [Lights],
})
export class GalleryLights {
	protected Math = Math
	protected lightPositions = [
		[0, 3.2, -10],
		[10, 3.2, 7.6],
		[-10, 3.2, 7.6],
	]
}
```
    </TabItem>
    <TabItem label="Floor">
For the floor, we use `ngt-primitive` in combination with `injectNgtsGLTFLoader()`. Interestingly, we also use `injectNgtsTextureLoader()` to load a _dictionary_ of textures for the floor. We then apply the textures to the `MeshStandardMaterial` for the floor.

```angular-ts {'1': 10, 17} {'2': 18-22} {'3': 72-74}
import { ChangeDetectionStrategy, Component, computed, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core'
import { checkUpdate, NgtArgs } from 'angular-three'
import { injectNgtsGLTFLoader, injectNgtsTextureLoader } from 'angular-three-soba/loaders'
import { MeshPhysicalMaterial, MeshStandardMaterial, RepeatWrapping, SRGBColorSpace, type Mesh } from 'three'

@Component({
	selector: 'app-floor',
	standalone: true,
	template: `
		<ngt-primitive *args="[model()]" />
	`,
	imports: [NgtArgs],
	schemas: [CUSTOM_ELEMENTS_SCHEMA],
	changeDetection: ChangeDetectionStrategy.OnPush,
})
export class Floor {
	private gltf = injectNgtsGLTFLoader(() => 'models/floorModel.glb')
	private textures = injectNgtsTextureLoader(() => ({
		diffuse: 'textures/hardwood_diffuse.jpg',
		bump: 'textures/hardwood_bump.jpg',
		roughness: 'textures/hardwood_roughness.jpg',
	}))

	protected model = computed(() => {
		const [gltf, textures] = [this.gltf(), this.textures()]
		if (!gltf || !textures) return null
		const { diffuse, roughness, bump } = textures
		const scene = gltf.scene

		let material: MeshStandardMaterial | MeshPhysicalMaterial = new MeshPhysicalMaterial({
			// clearcoat: 0,
			clearcoatRoughness: 0.1,
			// metalness: 0,
			roughness: 0.9,
			color: 0x54001b, // Teal: 0x004a54,
			// normalScale: new Vector2(0.15, 0.15)
		})

		scene.position.z = -0
		scene.scale.setScalar(3)

		scene.traverse((obj) => {
			if ((obj as Mesh).isMesh) {
				if (obj.name === 'Floor') {
					// Diffuse
					diffuse.wrapS = RepeatWrapping
					diffuse.wrapT = RepeatWrapping
					diffuse.anisotropy = 16
					diffuse.repeat.set(10, 24)
					diffuse.colorSpace = SRGBColorSpace
					checkUpdate(diffuse)

					// bump
					bump.wrapS = RepeatWrapping
					bump.wrapT = RepeatWrapping
					bump.anisotropy = 4
					bump.repeat.set(10, 24)
					checkUpdate(bump)

					// roughness
					roughness.wrapS = RepeatWrapping
					roughness.wrapT = RepeatWrapping
					roughness.anisotropy = 4
					roughness.repeat.set(10, 24)
					checkUpdate(roughness)

					material = new MeshStandardMaterial({
						roughness: 0.8,
						color: 0xffffff,
						metalness: 0.2,
						bumpScale: 0.0005,
						map: diffuse,
						bumpMap: bump,
						roughnessMap: roughness,
					})
				}

				;(obj as Mesh).material = material
				obj.castShadow = true
				obj.receiveShadow = true

				if (((obj as Mesh).material as MeshPhysicalMaterial).map) {
					;((obj as Mesh).material as MeshPhysicalMaterial).map!.anisotropy = 16
				}
			}
		})

		return scene
	})
}
```
    </TabItem>
    <TabItem label="Walls">
The walls is straightforward with `ngt-primitive` and `injectNgtsGLTFLoader()`

```angular-ts {'1': 9} {'2': 16}
import { ChangeDetectionStrategy, Component, computed, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core'
import { NgtArgs } from 'angular-three'
import { injectNgtsGLTFLoader } from 'angular-three-soba/loaders'

@Component({
	selector: 'app-walls',
	standalone: true,
	template: `
		<ngt-primitive *args="[model()]" />
	`,
	schemas: [CUSTOM_ELEMENTS_SCHEMA],
	changeDetection: ChangeDetectionStrategy.OnPush,
	imports: [NgtArgs],
})
export class Walls {
	private gltf = injectNgtsGLTFLoader(() => 'models/galleryInnerWalls.glb')
	protected model = computed(() => {
		const gltf = this.gltf()
		if (!gltf) return null

		const scene = gltf.scene

		scene.scale.setScalar(3)

		return scene
	})
}
```
    </TabItem>
</Tabs>

In fact, since `GallaryScene` is a composition of `Controls`, `Frames`, `GalleryLights`, `Floor`, and `Walls`, I can _comment out_ `<app-frames />` and show you what it looks like with just the `Controls`, `GalleryLights`, `Floor`, and `Walls`

<BlogImage
    src={framesCommentedOut}
    alt="Screenshot of the Angular Three rewrite with just the Controls, GalleryLights, Floor, and Walls"
/>

<BlogImage
    src={floorWalls}
    alt="Screenshot of the Angular Three rewrite with just the Controls, GalleryLights, Floor, and Walls"
/>

Well, this is also achievable by commenting out the `this.createFrames()` in the vanilla THREE.js counterpart. But what if you want to see the difference in the lighting setup with and without the base `<app-lights />`? You can do so very easily by commenting out `<app-lights />` in `<app-gallery-lights />`

<BlogImage
    src={lightsCommentedOut}
    alt="Screenshot of the Angular Three rewrite with just the Controls, GalleryLights (no base Lights), Floor, and Walls"
/>

<BlogImage
    src={noLights}
    alt="Screenshot of the Angular Three rewrite with just the Controls, GalleryLights (no base Lights), Floor, and Walls"
/>

## The Frames

This part consists of 5 image frames based on the `artworks()` data.

The Frames are created by the `createFrames()` method in the vanilla THREE.js version. The frames is a `Group` which contains all 5 individual image frames (1). Then, we iterate over the `artworks` array to create a frame for each artwork (2). We create the frame by calling `createFrame()` and then place the frame by calling `placeFrame()` (3). Finally, we add the frame to the `frames` group (4).

```angular-ts {'1': 1} {'2': 8-12} {'3': 14} {'4': 17}
frames: Group<Object3DEventMap> = new Group();

createFrames ( artworks: Artwork[], cb?: Function ) {
    this.frames.name = 'Frames Group';
    // Angle between frames
    this.angle = ( Math.PI * 2 ) / artworks.length || 5;

    const frames = artworks.map( ( artwork, i ) => {
      const f = this.placeFrame( this.createFrame( artwork ), i );
      f.name = `Frame ${i}`;
      return f;
    } );

    this.frames.add( ...frames );

    this.frames.position.set( 0, 1.6, 0 );
    this.focusFrame( 0 );

    return this.frames;
}
```

Let's look at the rewrite Angular Three version

First, we use the `ngt-group` to create the `Group` that contains all 5 image frames. Our `Frames` component accepts an Input `artworks` which is an array of `Artwork` objects. We use the `@for` control-flow to iterate over the `artworks` array to create a `Frame` for each artwork. We also create a `CylinderGeometry` that all 5 `Frame` will share.

```angular-ts {'1': 5,12} {'2': 19} {'3': 6-11} {'4': 21}
@Component({
	selector: 'app-frames',
	standalone: true,
	template: `
		<ngt-group name="Frames Group" [position]="[0, 1.6, 0]">
			@for (artwork of artworks(); track artwork.id) {
				<app-frame
					[artwork]="artwork"
					[geometry]="geometry"
				/>
			}
		</ngt-group>
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	schemas: [CUSTOM_ELEMENTS_SCHEMA],
	imports: [Frame],
})
export class Frames {
	artworks = input.required<Artwork[]>()

	protected geometry = new CylinderGeometry(1, 0.85, 0.1, 64, 5)

	private angle = computed(() => (Math.PI * 2) / this.artworks().length || 5)
}
```

There are also `placeFrame()` and `focusFrame()` which we touch on in later sections.

## The frame

Each image frame consists of three parts:

- The Frame itself which is a `Mesh`
- The image which is a `Mesh` with a `Texture`
- The buttons which are `Mesh` with `Text` on them (from `three-mesh-ui`)

<BlogImage
    src={fullFrame}
    alt="Screenshot a full frame"
/>

Surround all parts is a `Group`

<Tabs>
    <TabItem label="Vanilla THREE.js">
```angular-ts {'1': 2}
createFrame(artwork: Artwork) {
    const frame = new Group();
}
```
    </TabItem>
    <TabItem label="Angular Three">
```angular-html
<ngt-group #frameGroup></ngt-group>
```
    </TabItem>
</Tabs>

### The frame `Mesh`


<BlogImage
    src={frameOnly}
    alt="Screenshot the frame only"
/>

From the image, you might be able to tell that this is the first part of our `Frame` component which is the base/frame itself and it is using the `CylinderGeometry` that we create in the parent `Frames` component.

Let's take a look at the code for this part in both versions

<Tabs>
    <TabItem label="Vanilla THREE.js">
The code is removed in part that is not relevant to the frame creation. The Frame is straightforward to create. We create a `Mesh` with the `CylinderGeometry` and `MeshPhongMaterial` and then add it to the `frame` `Group`. The geometry is also rotated by 90 degree on the X axis **before** it is used on the `Mesh`.
```angular-ts
createFrame ( artwork: Artwork ) {
    this.frameGeometry.rotateX( Math.PI / 2 );

    // Create the frame
    const frameMaterial = this.phongMaterial.clone();
    frameMaterial.color.set( "rgb(165, 187, 206)" );
    frameMaterial.needsUpdate = true;
    const frameMesh = new Mesh( this.frameGeometry, frameMaterial );

    frameMesh.name = `${artwork.title} frame mesh` || 'frame';

    frame.add( frameMesh );

    return frame;
}
```
    </TabItem>
    <TabItem label="Angular Three">
As straightforward as the vanilla THREE.js version, we use the `ngt-mesh` element to create the `Mesh` with the passed in `CylinderGeometry` and a `ngt-mesh-phong-material`.
```angular-html {'Creating the Frame mesh as a child to the Frame group': 2-10} {'------>': 7}
<ngt-group #frameGroup>

    <ngt-mesh
        #frameMesh
        [name]="artwork().title + ' frame mesh'"
        [geometry]="geometry"
        (afterAttach)="onAfterAttach($any(frameMesh))"
    >
        <ngt-mesh-phong-material color="rgb(165, 187, 206)" [needsUpdate]="true" />
    </ngt-mesh>
</ngt-group>
```

Notice the `(afterAttach)` event that is used to call the `onAfterAttach()` method on the frame mesh. This is where we rotate the geometry. In the Angular Three version, we have to use the `queueMicrotask()` to ensure that the `frameMesh` is attached to the `frameGroup` before we rotate the geometry.

```angular-ts
onAfterAttach(frameMesh: Mesh) {
    queueMicrotask(() => {
        frameMesh.geometry.rotateX(Math.PI / 2)
    })
}
```

> `afterAttach()` is a special event in Angular Three that is triggered when the element is _attached_ to its parent element. This is useful when we need to perform an action on the element after it is attached to the scene graph.
    </TabItem>
</Tabs>

### The image `Mesh`

<BlogImage
    src={imageOnly}
    alt="Screenshot the image only"
/>

> If I haven't _bragged_ already, then these images are captured by commenting out parts of the `Frame` component template. Thanks to Angular Three.

<Tabs>
    <TabItem label="Vanilla THREE.js">
The code is removed in part that is not relevant to the image creation. The image is a `Mesh` with a `BoxGeometry` and a `MeshPhongMaterial` with a `Texture` applied to it. The image is then added to the `frame` `Group`. The image is also accompanied by a `SpotLight` that targets the image.
```angular-ts {'Creating the BoxGeometry': 2-3} {'Loading the texture for the Material': 5-12} {'Creating the Mesh': 14-17} {'Creating the SpotLight': 19-22} {'Adding the Mesh and the Light to the Frame group': 24-25}
createFrame ( artwork: Artwork ) {

    const canvasGeometry = new BoxGeometry( 1, 1, 0.12 );


    // Create the canvas material with the texture
    const texture = this.loadersService.loadTexture( artwork.url );
    texture.colorSpace = SRGBColorSpace;
    texture.mapping = UVMapping;
    const canvasMaterial = this.phongMaterial.clone();
    canvasMaterial.name = 'Canvas Material';
    canvasMaterial.map = texture;


    // Create the canvas mesh
    const canvasMesh = new Mesh( canvasGeometry, canvasMaterial );
    canvasMesh.name = 'Canvas';


    const light = this.lightsService.createSpotLight();
    light.target = canvasMesh;
    light.position.y = 2;


    frame.add( canvasMesh, light );

    return frame;
}
```
    </TabItem>
    <TabItem label="Angular Three">
```angular-ts {'Creating the Mesh': 6-7} {'Creating the BoxGeometry': 8-9} {'Creating the Material': 10-11} {'Load the texture using injectNgtsGLTFLoader': 35-42} {'Creating the SpotLight': 14-22}
@Component({
	template: `
		<ngt-group #frameGroup>
            <!--- truncated frame mesh -->


			<ngt-mesh #canvasMesh name="Canvas">

				<ngt-box-geometry *args="[1, 1, 0.12]" />

				<ngt-mesh-phong-material name="Canvas material" [map]="artworkTexture()" />
			</ngt-mesh>


			<ngt-spot-light
				[intensity]="30"
				[distance]="30"
				[angle]="Math.PI / 4"
				[penumbra]="0.5"
				[target]="canvasMesh"
				[position]="[0, 2, 0]"
			/>
		</ngt-group>
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	schemas: [CUSTOM_ELEMENTS_SCHEMA],
	imports: [NgtArgs, FrameButtons],
})
export class Frame {
	protected Math = Math

	geometry = input.required<CylinderGeometry>()
	artwork = input.required<Artwork>()


	protected artworkTexture = injectNgtsTextureLoader(() => this.artwork().url, {
		onLoad: ([texture]) => {
			texture.colorSpace = SRGBColorSpace
			texture.mapping = UVMapping
			checkUpdate(texture)
		},
	})
}
```
Notice how we can use **Template Variable** `#canvasMesh` to reference the `Mesh` element and assign it to the `[target]` input on the `SpotLight`? That is the power of Angular Three declarative approach. Everything that is familiar to Angular developers is available by using Angular Three.
    </TabItem>
</Tabs>

### The buttons

<BlogImage
    src={frameButtonsOnly}
    alt="Screenshot of the frame buttons only"
/>

<Tabs>
    <TabItem label="Vanilla THREE.js">
A lot is going on here to create the UI Buttons (Previous, Info, Next). These are created via `three-mesh-ui` library. The main key of this part is that these elements in the Canvas have to be interactive and have event listeners attached to them. This is tricky in THREE.js because the elements **do not** have DOM events as they're elements in a Canvas. This is where the Interaction Manager comes in but it is not developer friendly to add interactions to 3D elements.
```angular-ts {'Creating the buttons with createUI()': 2-3} {'Creating the group of buttons with createInteractiveButtons()': 12-13} {'Creating the container Block': 26-27} {'Looping through the buttons to create each button': 43-44} {'Creating the button with createButton()': 45-46} {'Each button is a Block': 54-55} {'with a Text inside': 58-59} {'with event listener via Interaction Manager': 79-81}
createFrame ( artwork: Artwork ) {

    const buttons = this.createUI( artwork );


    frame.add( buttons );

    return frame;
}

createUI ( artwork: Artwork ) {

    const buttonsPanel = this.UIService.createInteractiveButtons( { buttons: this.buttons, id: artwork.id } );
    buttonsPanel.position.x = 0;
    buttonsPanel.position.y = -0.7;
    buttonsPanel.position.z = -0.2;

    buttonsPanel.rotateY( Math.PI );
    buttonsPanel.rotateX( -0.55 );

    return buttonsPanel;
}

createInteractiveButtons ( options: any ) {
    const ops = Object.assign( {}, this.defaultOptions, options );

    const container = new ThreeMeshUI.Block(
      {
        justifyContent: 'center',
        contentDirection: 'row-reverse',
        fontFamily: this.FontJSON,
        fontTexture: this.FontImage,
        fontSize: 0.1,
        padding: 0.02,
        borderRadius: 0.11,
        height: 0.2,
        width: options.buttons.length / 2,
      }
    );
    container.name = ops.name;
    this.container = container;


    ops.buttons.forEach( ( o: any, i: number ) => {

      const button = this.createButton( ops.id, o );
      this.container.add( button );
    } );

    return container;
};

createButton ( id: number, ops?: any ) {

    const btn = new ThreeMeshUI.Block( this.buttonOptions );
    btn.name = `Frame ${id} ${ops.name}`;


    btn.add( new ThreeMeshUI.Text( {
      content: ops.text,
      name: `${ops.name} Text`,
    } ) );


    // @ts-ignore
    btn.setupState( {
      state: 'selected',
      attributes: this.selectedAttributes,
    } );

    // @ts-ignore
    btn.setupState( this.idleStateAttributes );
    // @ts-ignore
    btn.setupState( this.hoveredStateAttributes );


    btn.position.set( -0.5, 0, 0 );


    this.interactions.addToInteractions( btn );
    this.interactions.addToColliders( { mesh: btn, name: ops.name, cb: () => { ops.onClick( id ); } } );
    // @ts-ignore
    btn.addEventListener( 'click', () => { ops.onClick( id ); } );

    return btn;
}
```
    </TabItem>
    <TabItem label="Angular Three">
Things look a little manageable here in the Angular Three version. First, we use `extend()` to make `Block` available as `ngt-mesh-block` and `Text` available as `ngt-mesh-text`. Then, everything just happens on the template, even the Event Listener part via a familiar Event Binding syntax `(click)`. Since `FrameButtons` is a component, it can have Input as well as Outputs so we attach the `next`, `previous`, and `playInfo` outputs to the `(click)` event on the buttons accordingly.
```angular-ts {'Extending Angular Three element catalogue with extend() which makes ngt-mesh-block and ngt-mesh-text available': 2-3} {'Creating a Block with ngt-mesh-block': 9-10} {'Loop over the predefined buttons list': 11-12} {'Creating a Block for each button': 13-14} {'Adding the (click) event to button.onClick()': 18-19} {'Creating a Text inside the Block': 21-22} {'This is equivalent to this.addToRender(this.ui.update) but it wasn't shown in the Vanilla THREE.js code': 73-76}
import { Block, Text, update } from 'three-mesh-ui'

extend({ MeshBlock: Block, MeshText: Text })

@Component({
	selector: 'app-frame-buttons',
	standalone: true,
	template: `

		<ngt-mesh-block *args="[buttonsPanelArgs]" [position]="[0, -0.7, -0.2]" [rotation]="[0.55, Math.PI, 0]">

			@for (button of buttons; track $index) {

				<ngt-mesh-block
					*args="[buttonOptions]"
					[name]="'Frame ' + artwork().id + ' ' + button.text + ' Button'"
					[position]="button.position"

					(click)="$any($event).object.name === 'MeshUI-Frame' && button.onClick()"
				>

					<ngt-mesh-text
						*args="[{ content: button.text, name: 'Frame ' + artwork().id + ' ' + button.text + ' Button Text' }]"
					/>
				</ngt-mesh-block>
			}
		</ngt-mesh-block>
	`,
	imports: [NgtArgs],
	schemas: [CUSTOM_ELEMENTS_SCHEMA],
	changeDetection: ChangeDetectionStrategy.OnPush,
})
export class FrameButtons {
	protected Math = Math

	artwork = input.required<Artwork>()
	next = output()
	previous = output()
	playInfo = output()

	protected buttonOptions = DEFAULT_BUTTON_OPTIONS
	protected buttons = [
		{
			onClick: this.next.emit.bind(this.next),
			text: 'Next',
			position: [-0.75, 0, 0.0],
		},
		{
			onClick: this.playInfo.emit.bind(this.playInfo),
			text: 'Info',
			position: [-0.8, 0.8, -0.1],
		},
		{
			onClick: this.previous.emit.bind(this.previous),
			text: 'Previous',
			position: [0.75, 0, 0],
		},
	]
	protected buttonsPanelArgs = {
		name: 'Button Panel Container',
		justifyContent: 'center',
		contentDirection: 'row-reverse',
		fontFamily: 'fonts/Roboto-msdf.json',
		fontTexture: 'fonts/Roboto-msdf.png',
		fontSize: 0.1,
		padding: 0.02,
		borderRadius: 0.11,
		height: 0.2,
		width: this.buttons.length / 2,
	}

	constructor() {

		injectBeforeRender(() => {
			update()
		})
	}
}
```

> You might be wondering what is `(click)="$any($event).object.name === 'MeshUI-Frame' && button.onClick()"`? Angular Three provides its own event system out of the box. `Block` from `three-mesh-ui` creates an implicit `Frame` element as well as a `Block` element so Angular Three's event system captures two events when we click on the `Frame` element: one event for `Block`, and one event for `Frame`. We use `$any($event).object.name === 'MeshUI-Frame'` as a workaround to ensure that the event is only triggered once.

    </TabItem>
</Tabs>

### Other details

We skip a couple of methods like `placeFrame()`, `focusFrame()`, and `moveFrame()`. These methods are used to position the frame relative to the Frames group and to focus on a particular frame at a time. The way we implement this in Angular Three is different than in Vanilla THREE.js, not in the logic themselves but where to put them. In Angular Three, we leverage `afterAttach` event as a way to ensure the elements are ready before we perform any action on them.

<Tabs>
    <TabItem label="FramesComponent">
```angular-ts {'1 onFramesGroupAttached() to focus the first frame': 7-8, 43-44} {'2 onFrameAttached() to position the frame': 14-15,31-32}
@Component({
	selector: 'app-frames',
	standalone: true,
	template: `
		<ngt-group
		    name="Frames Group" [position]="[0, 1.6, 0]"

		    (afterAttach)="onFramesGroupAttached($any($event).node)"
        >
			@for (artwork of artworks(); track artwork.id) {
				<app-frame
					[artwork]="artwork"
					[geometry]="geometry"

					(frameAttached)="onFrameAttached($event, $index)"
				/>
			}
		</ngt-group>
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	schemas: [CUSTOM_ELEMENTS_SCHEMA],
	imports: [NgtArgs, Frame],
})
export class Frames {
	artworks = input.required<Artwork[]>()

	protected geometry = new CylinderGeometry(1, 0.85, 0.1, 64, 5)

	private frames = signal<Group>(null!)


	onFrameAttached(frame: Group, index: number) {
		frame.rotateY(Math.PI)
		const alpha = index * this.angle()
		const x = Math.sin(alpha) * 7 // 0 - 1
		const z = -Math.cos(alpha) * 7 // 0 - 0
		frame.position.set(x, 0, z)
		frame.rotation.y = alpha
		frame.userData['originalPosition'] = frame.position.clone()
		checkUpdate(frame)
	}


	onFramesGroupAttached(frames: Group) {
		this.frames.set(frames)
		// NOTE: we want to run this after all frames are attached
		queueMicrotask(() => {
			const f = frames.children[0]
			this.focusFrame(f)
		})
	}
```
    </TabItem>
    <TabItem label="FrameComponent">
```angular-ts {'frameAttached output to emit (afterAttach) back to parent Frames component': 7-8, 23-24}
@Component({
	selector: 'app-frame',
	standalone: true,
	template: `
		<ngt-group
			#frameGroup

			(afterAttach)="frameAttached.emit($any(frameGroup))"
		>
            <!-- truncated -->
		</ngt-group>
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	schemas: [CUSTOM_ELEMENTS_SCHEMA],
	imports: [NgtArgs, FrameButtons],
})
export class Frame {
	protected Math = Math

	geometry = input.required<CylinderGeometry>()
	artwork = input.required<Artwork>()


	frameAttached = output<Group>()

    /* truncated */
}
```
    </TabItem>
</Tabs>

### The interactions

Last step is to convert the Next, Previous, and Play Info events over. This is done by emitting the `next`, `previous`, and `playInfo` outputs from the `FrameButtons` component -> `Frame` component then handle the events in `Frames` component.

```angular-ts {'Listen to the events': 11-14} {'onNext() to go to the next Artwork index': 33-34} {'onPrevious() to go to the previous Artwork index': 44-45} {'onPlayInfo() to play the info with Web Speech API': 55-56}
@Component({
	selector: 'app-frames',
	standalone: true,
	template: `
		<ngt-group name="Frames Group" [position]="[0, 1.6, 0]" (afterAttach)="onFramesGroupAttached($any($event).node)">
			@for (artwork of artworks(); track artwork.id) {
				<app-frame
					[artwork]="artwork"
					[geometry]="geometry"
					(frameAttached)="onFrameAttached($event, $index)"

					(next)="onNext($event)"
					(previous)="onPrevious($event)"
					(playInfo)="onPlayInfo($event)"
				/>
			}
		</ngt-group>
	`,
	changeDetection: ChangeDetectionStrategy.OnPush,
	schemas: [CUSTOM_ELEMENTS_SCHEMA],
	imports: [NgtArgs, Frame],
})
export class Frames {
	artworks = input.required<Artwork[]>()

	protected geometry = new CylinderGeometry(1, 0.85, 0.1, 64, 5)

	private speechClient = inject(SpeechClient)

	private frames = signal<Group>(null!)
	private angle = computed(() => (Math.PI * 2) / this.artworks().length || 5)


	onNext(currentId: number) {
		const currentFrame = this.frames().children[currentId]
		this.resetFramePosition(currentFrame)

		// Rotate to Next frame
		const i = currentId < 5 - 1 ? currentId + 1 : 0
		this.rotateFrames(72)
		this.focusFrame(this.frames().children[i])
	}


	onPrevious(currentId: number) {
		const currentFrame = this.frames().children[currentId]
		this.resetFramePosition(currentFrame)

		// Rotate to Previous
		const i = currentId === 0 ? 5 - 1 : currentId - 1
		this.rotateFrames(-72)
		this.focusFrame(this.frames().children[i])
	}


	onPlayInfo(artwork: Artwork) {
		const text = artwork.description || artwork.title
		if (text) {
			void this.speechClient.speak(text)
		}
	}

	onFrameAttached(frame: Group, index: number) {
		frame.rotateY(Math.PI)
		const alpha = index * this.angle()
		const x = Math.sin(alpha) * 7 // 0 - 1
		const z = -Math.cos(alpha) * 7 // 0 - 0
		frame.position.set(x, 0, z)
		frame.rotation.y = alpha
		frame.userData['originalPosition'] = frame.position.clone()
		checkUpdate(frame)
	}

	onFramesGroupAttached(frames: Group) {
		this.frames.set(frames)
		// NOTE: we want to run this after all frames are attached
		queueMicrotask(() => {
			const f = frames.children[0]
			this.focusFrame(f)
		})
	}

	private focusFrame(frame: Object3D) {
		const x = (frame.position.x / 7) * 4
		const z = (frame.position.z / 7) * 4
		const p = new Vector3(x, frame.position.y, z)
		this.moveFrame(frame, p)
	}

	private moveFrame(frame: Object3D, position: Vector3) {
		animate({
			from: frame.position,
			to: position,
			duration: 2500,
			ease: easeInOut,
			onUpdate: (latest) => {
				frame.position.x = latest.x
				frame.position.y = latest.y
				frame.position.z = latest.z
			},
			onComplete: () => {
				checkUpdate(frame)
			},
		})
	}

	private resetFramePosition(frame: Object3D) {
		const position = frame.userData['originalPosition']
		this.moveFrame(frame, position)
	}

	private rotateFrames(angle: number = 72) {
		// angle between frames and the current group rotation
		const y = MathUtils.degToRad(angle) + this.frames().rotation.y
		animate({
			from: this.frames().rotation.y,
			to: y,
			duration: 1000,
			ease: easeInOut,
			onUpdate: (latest) => (this.frames().rotation.y = latest),
		})
	}
}
```

And voila, the application is converted fully to Angular Three. Here's the GIF of the running application again.

<BlogImage
	src={angularWebXR}
	format="gif"
	alt="Animated gif of the Angular WebXR application"
/>

Github:
- [Vanilla THREE.js](https://github.com/google-gemini/angular-webxr-art-sample)
- [Angular Three](https://github.com/nartc/ngt-web-art-sample)

## Conclusion

In this blog post, we have successfully converted a Vanilla THREE.js application to Angular Three. We have seen how Angular Three can help us to write cleaner and more maintainable code by leveraging Angular's template syntax and TypeScript. We have also seen how Angular Three can help us to manage the complexity of a 3D application by providing a declarative way to create and manage 3D elements.

The process is super fun for me personally and I hope you enjoy reading it as much as I enjoy writing it. If you have any questions or feedback, feel free to reach out to me on [Twitter](https://twitter.com/nartc1410).

Have fun coding!